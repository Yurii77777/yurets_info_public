import dumpingDetectPoster from "../img/articles-imgs/dumping-detect-poster.webp";
import dumpingDetectPosterTiny from "../img/articles-imgs/dumping-detect-poster_tiny.webp";
import sinoptik from "../img/articles-imgs/sinoptik.webp";
import sinoptikTiny from "../img/articles-imgs/sinoptik_tiny.webp";
import reactElectron from "../img/articles-imgs/react+electron.webp";
import dopomoshnychokTgBot from "../img/articles-imgs/dopomoshnychokTgBot.webp";
import dopomoshnychokTgBotTiny from "../img/articles-imgs/dopomoshnychokTgBotTiny.webp";
import nodeSSL from "../img/articles-imgs/NodeJS_SSL_result.webp";

export const articlesDescription = [
    {
        id: 0,
        articleTitleUa: "Детектор демпінгу v.1.0.0",
        articleTitleEng: "Dumping detector v.1.0.0",
        articleTitleRu: "Детектор демпинга v.1.0.0",
        shortDescriptionUa:
            "Детектор демпінгу цінової політики підприємства. \n Основні можливості:\n - автоматичний системний моніторинг цін на ринку у вказаний день (дні);\n - консолідація та представлення отриманих даних в зручному форматі;\n - запис попередніх цін клієнтів для порівняння з поточними;\n - інтеграція з Телеграм Ботом - після кожного сканування бот надсилає позиції в демпінгу користувачам, котрі підписалися на дані повідомлення.",
        fullDescriptionUa:
            "v.1.0.0 \n Детектор демпінгу цінової політики підприємства. \n Основні можливості:\n - автоматичний системний моніторинг цін на ринку у вказаний день (дні);\n - консолідація та представлення отриманих даних в зручному форматі;\n - запис попередніх цін клієнтів для порівняння з поточними;\n - інтеграція з Телеграм Ботом - після кожного сканування бот надсилає позиції в демпінгу користувачам, котрі підписалися на дані повідомлення.",
        shortDescriptionEng:
            "Dumping detector of the company's pricing policy. \n Key features:\n - - automatic system monitoring of market prices on the specified day(s);\n - consolidation and presentation of the received data in a convenient format;\n - record of previous customer prices for comparison with current ones;\n - integration with Telegram Bot - after each scan, the bot sends positions in dumping to users who have subscribed to these messages.",
        fullDescriptionEng:
            "v.1.0.0 \n Dumping detector of the company's pricing policy. \n Key features:\n - - automatic system monitoring of market prices on the specified day(s);\n - consolidation and presentation of the received data in a convenient format;\n - record of previous customer prices for comparison with current ones;\n - integration with Telegram Bot - after each scan, the bot sends positions in dumping to users who have subscribed to these messages.",
        shortDescriptionRu:
            "Детектор демпинга ценовой политики компании. \n Основные возможности:\n - автоматический системный мониторинг цен на рынке в указанный день (дни);\n - консолидация и представление полученных данных в удобном формате;\n - запись предварительных цен клиентов для сравнения с текущими;\n - интеграция с Телеграмм Ботом – после каждого сканирования бот присылает позиции в демпинге пользователям, подписавшимся на данные сообщения.",
        fullDescriptionRu:
            "v.1.0.0 \n Детектор демпинга ценовой политики компании. \n Основные возможности:\n - автоматический системный мониторинг цен на рынке в указанный день (дни);\n - консолидация и представление полученных данных в удобном формате;\n - запись предварительных цен клиентов для сравнения с текущими;\n - интеграция с Телеграмм Ботом – после каждого сканирования бот присылает позиции в демпинге пользователям, подписавшимся на данные сообщения.",
        posterImg: dumpingDetectPoster,
        tinyPosterImg: dumpingDetectPosterTiny,
        category: "services",
        url: "/dumping-detector",
    },
    {
        id: 1,
        articleTitleUa: "Sinoptik v.1.0.0",
        articleTitleEng: "Sinoptik v.1.0.0",
        articleTitleRu: "Sinoptik v.1.0.0",
        shortDescriptionUa:
            "Односторінковий веб-додаток для автоматичного завантаження погоди. \n Кожну годину программа оновлює актуальну інформацію із сервісу https://www.weatherbit.io/ по локації Софіївська Борщагівка. В майбутньому (можливо) буде змога передавати координати для отримання погодних умов в будь-якій точці планети, наразі перед даним додатком стоять інші цілі. \n Верстка з макету Figma, дякую за макети / іконки @iamchandravadan та @iankornilov",
        shortDescriptionEng:
            "SPA for automatic weather downloads. \n The program every hour updates the latest information from the service https://www.weatherbit.io/ at the location Sofiyivska Borshchahivka. In the future (possibly) the program will be able to obtain coordinates to display weather conditions from any part of the planet, currently this application has other goals. \n Layout from Figma layout, thanks for @iamchandravadan and @iankornilov layouts / icons",
        shortDescriptionRu:
            "Одностраничное веб-приложение для автоматической загрузки погоды. Каждый час программа обновляет актуальную информацию с сервиса https://www.weatherbit.io/ по локации Софиевская Борщаговка. В будущем (возможно) будет возможность передавать координаты для получения погодных условий в любой точке планеты, пока перед данным приложением стоят другие цели. \n Верстка из макета Figma, спасибо за макеты / иконки @iamchandravadan и @iankornilov",
        posterImg: sinoptik,
        tinyPosterImg: sinoptikTiny,
        category: "spa",
        url: "/sinoptik",
    },
    {
        id: 2,
        articleTitleUa: "React + Electron JS",
        articleTitleEng: "React + Electron JS",
        articleTitleRu: "React + Electron JS",
        shortDescriptionUa:
            "1. Створюємо новий REACT додаток, в терміналі Вашого редактора вводимо команду:\n <code>npx create-react-app name-of-app</code>\n 2. В папці із новоствореною програмою встановлюємо два пакети:\n <code>npm install electron --save-dev\n npm install electron-is-dev</code>\n 3. В папці 'src' створюємо ще дві папки: 'react' та 'shared'.\n 4. Всі файли React проекту із папки 'src' переміщаємо в директорію 'src/react'. В директорії 'src' залишаємо тільки вхідний файл index.js.\n * Не забуваємо замінити імпорти в файлі index.js\n 5. В директорії 'shared' створюємо файл 'constants.js' з наступним вмістом:\n <code>module.exports = {</code>\n <code>channels: { APP_INFO: 'app_info', },</code>\n <code>};</code>\n 6. Встановити всі необхідні пакети (залежності) до проекту із package.json\n <code>npm install</code>\n 7. Збираємо react-программу\n <code>npm run build</code>\n 8. В директорії 'build' створити директорію 'electron'\n 9. В директорії 'electron' створити файл 'main.js' із наступним змістом:\n <code>const { app, BrowserWindow } = require('electron');</code>\n <code>const isDev = require('electron-is-dev');</code>\n <code>const path = require('path');</code>\n <code>const win = null;</code>\n <code>const createWindow = (win) => {</code>\n <code>win = new BrowserWindow({ width: 1124, height: 800,</code>\n <code>webPreferences: { nodeIntegration: true }</code>\n <code>});</code>\n <code>win.loadURL(isDev ? 'http://localhost:3000' : `file://${path.join(__dirname, '../index.html')}`);</code>\n <code>};</code>\n <code>app.whenReady().then(() => {</code>\n <code>createWindow(win);</code>\n <code>app.on('window-all-closed', () => {</code>\n <code>process.platform !== 'darwin' && app.quit();</code>\n <code>});</code>\n <code>app.on('activate', () => {</code>\n <code>BrowserWindow.getAllWindows().length === 0 && createWindow(win);</code>\n <code>});</code>\n <code>});</code>\n 10. В директорії 'electron' створити новий файл 'preload.js' з наступним змістом:\n <code>const { ipcRenderer } = require('electron');</code>\n <code>window.ipcRenderer = ipcRenderer;</code>\n 11. Оновлюємо файл main.js для створення головного вікна програми\n <code>preload: path.join(__dirname, 'preload.js'),</code>\n 12. Встановлюємо пакет для збірки програми для ПК\n <code>npm install --save-dev electron-builder</code>\n 13. В package.json додаємо нові елементи та команди\n <code>'productName': 'app-name',</code>\n <code>'main': 'electron/main.js',</code>\n <code>'homepage': './',</code>\n <code>'scripts': { 'package': 'electron-builder build --mac --win -c.extraMetadata.main=build/electron/main.js --publish never' }</code>\n 14. Запускаємо збірку та користуємося react-додатком як ПК програмою ;)\n <code>npm run package</code>",
        shortDescriptionEng:
            "Let's create a new REACT application, in the terminal of your editor, enter the command:\n <code>npx create-react-app name-of-app</code>\n 2. In the folder with the newly created program, install two packages:\n <code>npm install electron --save-dev\n npm install electron-is-dev</code>\n 3. Inside the 'src' directory create two directories: 'react' and 'shared'.\n 4. Replace all React project files from the 'src' directory to the 'src / react' directory. Only the input file index.js should be in the 'src' directory.\n * Do not forget to replace the imports in the file index.js\n 5. In the 'shared' directory, create a file 'constants.js' with the following content::\n <code>module.exports = {</code>\n <code>channels: { APP_INFO: 'app_info', },</code>\n <code>};</code>\n 6. Install all necessary packages (dependencies) to the project from package.json\n <code>npm install</code>\n 7. Build the react program\n <code>npm run build</code>\n 8. In the 'build' directory, create an 'electron' directory\n 9. In the 'electron' directory, create a 'main.js' file with the following contents:\n <code>const { app, BrowserWindow } = require('electron');</code>\n <code>const isDev = require('electron-is-dev');</code>\n <code>const path = require('path');</code>\n <code>const win = null;</code>\n <code>const createWindow = (win) => {</code>\n <code>win = new BrowserWindow({ width: 1124, height: 800,</code>\n <code>webPreferences: { nodeIntegration: true }</code>\n <code>});</code>\n <code>win.loadURL(isDev ? 'http://localhost:3000' : `file://${path.join(__dirname, '../index.html')}`);</code>\n <code>};</code>\n <code>app.whenReady().then(() => {</code>\n <code>createWindow(win);</code>\n <code>app.on('window-all-closed', () => {</code>\n <code>process.platform !== 'darwin' && app.quit();</code>\n <code>});</code>\n <code>app.on('activate', () => {</code>\n <code>BrowserWindow.getAllWindows().length === 0 && createWindow(win);</code>\n <code>});</code>\n <code>});</code>\n 10. In the directory 'electron' create a new file 'preload.js' with the following content:\n <code>const { ipcRenderer } = require('electron');</code>\n <code>window.ipcRenderer = ipcRenderer;</code>\n 11. Update the main.js file to create the main program window\n <code>preload: path.join(__dirname, 'preload.js'),</code>\n 12. Install the PC build package\n <code>npm install --save-dev electron-builder</code>\n 13. In package.json add new elements and commands\n <code>'productName': 'app-name',</code>\n <code>'main': 'electron/main.js',</code>\n <code>'homepage': './',</code>\n <code>'scripts': { 'package': 'electron-builder build --mac --win -c.extraMetadata.main=build/electron/main.js --publish never' }</code>\n 14. Run the build and use the react-application as a PC program ;)\n <code>npm run package</code>",
        shortDescriptionRu:
            "Создаем новое REACT приложение, в терминале Вашего редактора вводим команду:\n <code>npx create-react-app name-of-app</code>\n 2. В папке с новой программой устанавливаем два пакета:\n <code>npm install electron --save-dev\n npm install electron-is-dev</code>\n 3. В папке 'src' создаем еще две папки: 'react' и 'shared'.\n 4. Все файлы React проекта из папки 'src' перемещаем в директорию 'src/react'. В директории 'src' оставляем только входящий файл index.js.\n* Не забываем заменить импорты в файле index.js\n 5. В директории 'shared' создаем файл 'constants.js' со следующим содержимым:\n <code>module.exports = {</code>\n <code>channels: { APP_INFO: 'app_info', },</code>\n <code>};</code>\n 6. Установить все необходимые пакеты (зависимости) в проект с package.json\n <code>npm install</code>\n 7. Собираем react-программу\n <code>npm run build</code>\n 8. В директории 'build' создать директорию 'electron'\n 9. В директории 'electron' создать файл 'main.js' со следующим содержанием:\n <code>const { app, BrowserWindow } = require('electron');</code>\n <code>const isDev = require('electron-is-dev');</code>\n <code>const path = require('path');</code>\n <code>const win = null;</code>\n <code>const createWindow = (win) => {</code>\n <code>win = new BrowserWindow({ width: 1124, height: 800,</code>\n <code>webPreferences: { nodeIntegration: true }</code>\n <code>});</code>\n <code>win.loadURL(isDev ? 'http://localhost:3000' : `file://${path.join(__dirname, '../index.html')}`);</code>\n <code>};</code>\n <code>app.whenReady().then(() => {</code>\n <code>createWindow(win);</code>\n <code>app.on('window-all-closed', () => {</code>\n <code>process.platform !== 'darwin' && app.quit();</code>\n <code>});</code>\n <code>app.on('activate', () => {</code>\n <code>BrowserWindow.getAllWindows().length === 0 && createWindow(win);</code>\n <code>});</code>\n <code>});</code>\n 10. В директории 'electron' создать новый файл 'preload.js' со следующим содержанием:\n <code>const { ipcRenderer } = require('electron');</code>\n <code>window.ipcRenderer = ipcRenderer;</code>\n 11. Обновляем файл main.js для создания главного окна программы\n <code>preload: path.join(__dirname, 'preload.js'),</code>\n 12. Устанавливаем пакет для сборки программы для ПК\n <code>npm install --save-dev electron-builder</code>\n 13. В package.json добавляем новые элементы и команды\n <code>'productName': 'app-name',</code>\n <code>'main': 'electron/main.js',</code>\n <code>'homepage': './',</code>\n <code>'scripts': { 'package': 'electron-builder build --mac --win -c.extraMetadata.main=build/electron/main.js --publish never' }</code>\n 14. Запускаем сборку и пользуемся react-приложением как ПК программой ;)\n <code>npm run package</code>",
        posterImg: reactElectron,
        category: "manuals",
        url: "/react+electron-js",
    },
    {
        id: 3,
        articleTitleUa: "Dopomoshnychok v.2.0.0",
        articleTitleEng: "Dopomoshnychok v.2.0.0",
        articleTitleRu: "Dopomoshnychok v.2.0.0",
        shortDescriptionUa:
            "Допомошничок - Телеграм Бот, інтегрований в різноманітні сервіси даного порталу.\n Оформлює підписку на розсилку та розсилає повідомлення користувачам, котрі підписалися на обрані івенти.\n",
        fullDescriptionUa:
            "v. 1.0.0 - повна інтеграція із сервісом DUMPING DETECTOR.\n Можливості Бота по даному сервісу:\n - допомогає користувачу оформити корректну підписку на повідомлення, в залежності від того, що саме хоче отримувати користувач;\n - після кожного оновлення цін, надсилає користувачам повідомлення за обраними підписками із позиціями у демпінгу;\n - показує список оформлених підписок користувачем;\n - видаляє підписку вказану користувачем;\n - користувачу із правами 'admin' надсилає системні повідомлення із даного сервісу (збій сканування, тощо)\n\n v.2.0.0\n - заміна API на telegraf.js\n- підключена БД MongoDB",
        shortDescriptionEng:
            "Dopomoshnychok - Telegram Bot, integrated into various services of this portal.\n Creates a subscription to the newsletter and sends messages to users who have subscribed to the selected events.\n",
        fullDescriptionEng:
            "v. 1.0.0 - full integration with the DUMPING DETECTOR service.\n What the Bot can do with this service:\n - helps the user to issue the correct subscription to messages, depending on what exactly the user wants to receive;\n - after each price update, sends messages to users for selected subscriptions with dumping positions;\n - shows the list of subscriptions issued by the user;\n - deletes the subscription selected by the user;\n - sends system messages from this service to a user with 'admin' rights (scanning failure, etc.)\n\n v.2.0.0\n - replacement of API with telegraf.js\n - connected MongoDB database",
        shortDescriptionRu:
            "Допомошничок - Телеграмм Бот, интегрированный в различные сервисы данного портала.\n Оформляет подписку на рассылку и рассылает сообщения пользователям, подписавшимся на выбранные инвенты.\n",
        fullDescriptionRu:
            "v. 1.0.0 - полная интеграция с сервисом DUMPING DETECTOR.\n Возможности Бота по данному сервису:\n - помогает пользователю оформить корректную подписку на уведомления, в зависимости от того, что именно хочет получать пользователь;\n - после каждого обновления цен, посылает пользователям сообщения по выбранным подпискам с позициями в демпинге; \n - показывает список оформленных подписок пользователем;\n - удаляет подписку указанную пользователем;\n - пользователю с правами 'admin' посылает системные сообщения с данного сервиса (сбой сканирования и т.д.)\n\n v.2.0.0\n - замена API на telegraf.js\n- подключена БД MongoDB",
        posterImg: dopomoshnychokTgBot,
        tinyPosterImg: dopomoshnychokTgBotTiny,
        category: "projects",
        url: "/dopomoshnychok",
    },
    {
        id: 4,
        articleTitleUa: "Як прикрутити SSL сертифікати на NodeJS",
        articleTitleEng: "How to install SSL certificates on NodeJS",
        articleTitleRu: "Как прикрутить SSL сертификаты на NodeJS",
        shortDescriptionUa:
            "Генеруємо безкоштовні сертифікати, приміром через сервіс zerossl.com, правда всього на три місяці, але для тесту згодиться. А далі будемо подивитися ;)\nУ вашій 'точці входу', приміром app.js підключаємо:\n<code>const http = require('http');</code>\n<code>const https = require('https');</code>\n<code>const fs = require('fs');</code>\nСтворюємо константи:\n<code>const hostName = config.get('baseUrl'); // тут пишемо Ваш домен, я його беру через конфіг, доволі зручно (приміром, yurets.info)</code>\n<code>const httpPort = 3000; // скрізь пишуть ставити порт 80 || 8080, у мене не запустився, Апач його зайняв, я вже і Апач вимикав, все одно прийшлося міняти порт</code?\n<code>const httpsPort = 443;</code>\nФормуємо об’єкт з налаштуваннями для https-серверу:\n<code>const httpsOptions = {</code>\n  <code>cert: fs.readFileSync('./каталог-з-сертифікатами/certificate.crt'),</code>\n  <code>ca: fs.readFileSync('./каталог-з-сертифікатами/ca_bundle.crt'),</code>\n  <code>key: fs.readFileSync('./каталог-з-сертифікатами/private.key'),</code>\n<code>};</code>\nПісля запуска Експреса\n<code>const app = express();</code>\nформуємо http та https сервери\n<code>const httpServer = http.createServer(app);</code>\n<code>const httpsServer = https.createServer(httpsOptions, app);</code>\nІ в режимі продакшн за допомогою Експресу робимо переадресацію із http на https\n<code>if (process.env.NODE_ENV === 'production') {</code>\n  <code>app.use((req, res, next) => {</code>\n  <code>if (req.protocol === 'http') {</code>\n  <code>res.redirect(301, `https://${req.headers.host}${req.url}`);</code>\n<code>}</code>\n<code>next();</code>\n<code>});</code>\n<code>app.use('/', express.static(path.join(__dirname, 'client', 'build')));</code>\n<code>app.get('*', (req, res) => {</code>\n<code>res.sendFile(path.resolve(__dirname, 'client', 'build', 'index.html'));</code>\n<code>});</code>\n<code>}</code>\nФініш, десь знизу запускаємо обидва сервери\n<code>httpServer.listen(httpPort, hostName);</code>\n<code>httpsServer.listen(httpsPort, hostName);</code>",
        shortDescriptionEng:
            "We need to generate free certificates, for example using the zerossl.com service. This site issues free SSL certificates for only three months, but it will work for the test. And then we'll see ;)\nIn your 'entry point', for example app.js, we need to connect:\n<code>const http = require('http');</code>\n<code>const https = require('https');</code>\n<code>const fs = require('fs');</code>\nNext, we create constants:\n<code>const hostName = config.get('baseUrl'); // here we write your domain, I take it from the configuration, it is quite convenient (for example, yurets.info)</code>\n<code>const httpPort = 3000; // everywhere they write to set port 80 || 8080, it didn’t start for me, Apache took it, I already turned off Apache, I still had to change the port</code?\n<code>const httpsPort = 443;</code>\nWe create an object with settings for the https server:\n<code>const httpsOptions = {</code>\n  <code>cert: fs.readFileSync('./directory-with-certificates/certificate.crt'),</code>\n  <code>ca: fs.readFileSync('./directory-with-certificates/ca_bundle.crt'),</code>\n  <code>key: fs.readFileSync('./directory-with-certificates/private.key'),</code>\n<code>};</code>\nAfter starting Express\n<code>const app = express();</code>\nwe create http and https servers\n<code>const httpServer = http.createServer(app);</code>\n<code>const httpsServer = https.createServer(httpsOptions, app);</code>\nAnd in production mode, we must redirect from http to https using Express\n<code>if (process.env.NODE_ENV === 'production') {</code>\n  <code>app.use((req, res, next) => {</code>\n  <code>if (req.protocol === 'http') {</code>\n  <code>res.redirect(301, `https://${req.headers.host}${req.url}`);</code>\n<code>}</code>\n<code>next();</code>\n<code>});</code>\n<code>app.use('/', express.static(path.join(__dirname, 'client', 'build')));</code>\n<code>app.get('*', (req, res) => {</code>\n<code>res.sendFile(path.resolve(__dirname, 'client', 'build', 'index.html'));</code>\n<code>});</code>\n<code>}</code>\nFinish, somewhere below we start both servers\n<code>httpServer.listen(httpPort, hostName);</code>\n<code>httpsServer.listen(httpsPort, hostName);</code>",
        shortDescriptionRu:
            "Генерируем бесплатные сертификаты, например через сервис zerossl.com, правда всего на три месяца, но для теста пригодится. А дальше будем посмотреть;)\nВ вашей 'точке входа', например app.js подключаем:\n<code>const http = require('http');</code>\n<code>const https = require('https');</code>\n<code>const fs = require('fs');</code>\nСоздаем константы:\n<code>const hostName = config.get('baseUrl'); // здесь пишем Ваш домен, я его беру через конфиг, довольно удобно (например, yurets.info)</code>\n<code>const httpPort = 3000; // везде пишут ставить порт 80 || 8080, у меня не запустился, Апач его занял, я уже и Апач выключал, все равно пришлось менять порт</code?\n<code>const httpsPort = 443;</code>\nФормируем объект с настройками для https-сервера:\n<code>const httpsOptions = {</code>\n  <code>cert: fs.readFileSync('./каталог-с-сертификатами/certificate.crt'),</code>\n  <code>ca: fs.readFileSync('./каталог-с-сертификатами/ca_bundle.crt'),</code>\n  <code>key: fs.readFileSync('./каталог-с-сертификатами/private.key'),</code>\n<code>};</code>\nПосле запуска Экспресса\n<code>const app = express();</code>\nформируем http и https серверы\n<code>const httpServer = http.createServer(app);</code>\n<code>const httpsServer = https.createServer(httpsOptions, app);</code>\nИ в режиме продакшн с помощью экспресса делаем переадресацию с http на https\n<code>if (process.env.NODE_ENV === 'production') {</code>\n  <code>app.use((req, res, next) => {</code>\n  <code>if (req.protocol === 'http') {</code>\n  <code>res.redirect(301, `https://${req.headers.host}${req.url}`);</code>\n<code>}</code>\n<code>next();</code>\n<code>});</code>\n<code>app.use('/', express.static(path.join(__dirname, 'client', 'build')));</code>\n<code>app.get('*', (req, res) => {</code>\n<code>res.sendFile(path.resolve(__dirname, 'client', 'build', 'index.html'));</code>\n<code>});</code>\n<code>}</code>\nФиниш, где-то снизу запускаем оба сервера\n<code>httpServer.listen(httpPort, hostName);</code>\n<code>httpsServer.listen(httpsPort, hostName);</code>",
        posterImg: nodeSSL,
        category: "manuals",
        url: "/nodejs&SSL",
    },
];
